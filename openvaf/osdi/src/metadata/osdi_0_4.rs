//! Generated by `gen_osdi_structs`, do not edit by hand.

use mir_llvm::CodegenCx;

const STDLIB_BITCODE_X86_64_UNKNOWN_LINUX_GNU: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_x86_64-unknown-linux-gnu.bc"));
const STDLIB_BITCODE_X86_64_PC_WINDOWS_MSVC: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_x86_64-pc-windows-msvc.bc"));
const STDLIB_BITCODE_X86_64_APPLE_MACOSX10_15_0: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_x86_64-apple-macosx10.15.0.bc"));
const STDLIB_BITCODE_AARCH64_UNKNOWN_LINUX_GNU: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_aarch64-unknown-linux-gnu.bc"));
const STDLIB_BITCODE_AARCH64_PC_WINDOWS_MSVC: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_aarch64-pc-windows-msvc.bc"));
const STDLIB_BITCODE_ARM64_APPLE_MACOSX11_0_0: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_arm64-apple-macosx11.0.0.bc"));
const STDLIB_BITCODE_X86_64_PC_WINDOWS_GNU: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_x86_64-pc-windows-gnu.bc"));
const STDLIB_BITCODE_RISCV64_UNKNOWN_LINUX_GNU: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/stdlib_0_4_riscv64-unknown-linux-gnu.bc"));
pub fn stdlib_bitcode(target: &target::spec::Target) -> &'static [u8] {
    match &*target.llvm_target {
        "x86_64-unknown-linux-gnu" => STDLIB_BITCODE_X86_64_UNKNOWN_LINUX_GNU,
        "x86_64-pc-windows-msvc" => STDLIB_BITCODE_X86_64_PC_WINDOWS_MSVC,
        "x86_64-apple-macosx10.15.0" => STDLIB_BITCODE_X86_64_APPLE_MACOSX10_15_0,
        "aarch64-unknown-linux-gnu" => STDLIB_BITCODE_AARCH64_UNKNOWN_LINUX_GNU,
        "aarch64-pc-windows-msvc" => STDLIB_BITCODE_AARCH64_PC_WINDOWS_MSVC,
        "arm64-apple-macosx11.0.0" => STDLIB_BITCODE_ARM64_APPLE_MACOSX11_0_0,
        "x86_64-pc-windows-gnu" => STDLIB_BITCODE_X86_64_PC_WINDOWS_GNU,
        "riscv64-unknown-linux-gnu" => STDLIB_BITCODE_RISCV64_UNKNOWN_LINUX_GNU,
        triple => unreachable!("unknown target triple {triple}"),
    }
}
pub const OSDI_VERSION_MAJOR_CURR: u32 = 0;
pub const OSDI_VERSION_MINOR_CURR: u32 = 4;
pub const PARA_TY_MASK: u32 = 3;
pub const PARA_TY_REAL: u32 = 0;
pub const PARA_TY_INT: u32 = 1;
pub const PARA_TY_STR: u32 = 2;
pub const PARA_KIND_MASK: u32 = (3 << 30);
pub const PARA_KIND_MODEL: u32 = (0 << 30);
pub const PARA_KIND_INST: u32 = (1 << 30);
pub const PARA_KIND_OPVAR: u32 = (2 << 30);
pub const ACCESS_FLAG_READ: u32 = 0;
pub const ACCESS_FLAG_SET: u32 = 1;
pub const ACCESS_FLAG_INSTANCE: u32 = 4;
pub const JACOBIAN_ENTRY_RESIST_CONST: u32 = 1;
pub const JACOBIAN_ENTRY_REACT_CONST: u32 = 2;
pub const JACOBIAN_ENTRY_RESIST: u32 = 4;
pub const JACOBIAN_ENTRY_REACT: u32 = 8;
pub const CALC_RESIST_RESIDUAL: u32 = 1;
pub const CALC_REACT_RESIDUAL: u32 = 2;
pub const CALC_RESIST_JACOBIAN: u32 = 4;
pub const CALC_REACT_JACOBIAN: u32 = 8;
pub const CALC_NOISE: u32 = 16;
pub const CALC_OP: u32 = 32;
pub const CALC_RESIST_LIM_RHS: u32 = 64;
pub const CALC_REACT_LIM_RHS: u32 = 128;
pub const ENABLE_LIM: u32 = 256;
pub const INIT_LIM: u32 = 512;
pub const ANALYSIS_NOISE: u32 = 1024;
pub const ANALYSIS_DC: u32 = 2048;
pub const ANALYSIS_AC: u32 = 4096;
pub const ANALYSIS_TRAN: u32 = 8192;
pub const ANALYSIS_IC: u32 = 16384;
pub const ANALYSIS_STATIC: u32 = 32768;
pub const ANALYSIS_NODESET: u32 = 65536;
pub const EVAL_RET_FLAG_LIM: u32 = 1;
pub const EVAL_RET_FLAG_FATAL: u32 = 2;
pub const EVAL_RET_FLAG_FINISH: u32 = 4;
pub const EVAL_RET_FLAG_STOP: u32 = 8;
pub const LOG_LVL_MASK: u32 = 7;
pub const LOG_LVL_DEBUG: u32 = 0;
pub const LOG_LVL_DISPLAY: u32 = 1;
pub const LOG_LVL_INFO: u32 = 2;
pub const LOG_LVL_WARN: u32 = 3;
pub const LOG_LVL_ERR: u32 = 4;
pub const LOG_LVL_FATAL: u32 = 5;
pub const LOG_FMT_ERR: u32 = 16;
pub const INIT_ERR_OUT_OF_BOUNDS: u32 = 1;
pub const ATTR_TYPE_STR: u32 = 0;
pub const ATTR_TYPE_INT: u32 = 1;
pub const ATTR_TYPE_REAL: u32 = 2;
pub const NATREF_NONE: u32 = 0;
pub const NATREF_NATURE: u32 = 1;
pub const NATREF_DISCIPLINE_FLOW: u32 = 2;
pub const NATREF_DISCIPLINE_POTENTIAL: u32 = 3;
pub const DOMAIN_NOT_GIVEN: u32 = 0;
pub const DOMAIN_DISCRETE: u32 = 1;
pub const DOMAIN_CONTINUOUS: u32 = 2;

pub struct OsdiLimFunction<'ll> {
    pub name: String,
    pub num_args: u32,
    pub func_ptr: &'ll llvm_sys::LLVMValue,
}
impl<'ll> OsdiLimFunction<'ll> {
    pub fn to_ll_val(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_unsigned_int(self.num_args),
            self.func_ptr,
        ];
        let ty = tys.osdi_lim_function;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_lim_function(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_ptr(), ctx.ty_int(), ctx.ty_ptr()];
        let ty = ctx.ty_struct("OsdiLimFunction", &fields);
        self.osdi_lim_function = Some(ty);
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_sim_paras(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_ptr(), ctx.ty_ptr(), ctx.ty_ptr(), ctx.ty_ptr()];
        let ty = ctx.ty_struct("OsdiSimParas", &fields);
        self.osdi_sim_paras = Some(ty);
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_sim_info(&mut self) {
        let ctx = self.ctx;
        let fields = [
            self.osdi_sim_paras.unwrap(),
            ctx.ty_double(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_int(),
        ];
        let ty = ctx.ty_struct("OsdiSimInfo", &fields);
        self.osdi_sim_info = Some(ty);
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_init_error_payload(&mut self) {
        let ctx = self.ctx;
        unsafe {
            let align = [llvm_sys::target::LLVMABIAlignmentOfType(
                self.target_data.clone(),
                core::ptr::NonNull::from(ctx.ty_int()).as_ptr(),
            )]
            .into_iter()
            .max()
            .unwrap();
            let mut size = [llvm_sys::target::LLVMABISizeOfType(
                self.target_data.clone(),
                core::ptr::NonNull::from(ctx.ty_int()).as_ptr(),
            )]
            .into_iter()
            .max()
            .unwrap() as u32;
            size = (size + align - 1) / align;
            let elem = ctx.ty_aint(align * 8);
            let ty = ctx.ty_array(elem, size);
            self.osdi_init_error_payload = Some(ty);
        }
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_init_error(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_int(), self.osdi_init_error_payload.unwrap()];
        let ty = ctx.ty_struct("OsdiInitError", &fields);
        self.osdi_init_error = Some(ty);
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_init_info(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_int(), ctx.ty_int(), ctx.ty_ptr()];
        let ty = ctx.ty_struct("OsdiInitInfo", &fields);
        self.osdi_init_info = Some(ty);
    }
}
pub struct OsdiNodePair {
    pub node_1: u32,
    pub node_2: u32,
}
impl OsdiNodePair {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [ctx.const_unsigned_int(self.node_1), ctx.const_unsigned_int(self.node_2)];
        let ty = tys.osdi_node_pair;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_node_pair(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_int(), ctx.ty_int()];
        let ty = ctx.ty_struct("OsdiNodePair", &fields);
        self.osdi_node_pair = Some(ty);
    }
}
pub struct OsdiJacobianEntry {
    pub nodes: OsdiNodePair,
    pub react_ptr_off: u32,
    pub flags: u32,
}
impl OsdiJacobianEntry {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            self.nodes.to_ll_val(ctx, tys),
            ctx.const_unsigned_int(self.react_ptr_off),
            ctx.const_unsigned_int(self.flags),
        ];
        let ty = tys.osdi_jacobian_entry;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_jacobian_entry(&mut self) {
        let ctx = self.ctx;
        let fields = [self.osdi_node_pair.unwrap(), ctx.ty_int(), ctx.ty_int()];
        let ty = ctx.ty_struct("OsdiJacobianEntry", &fields);
        self.osdi_jacobian_entry = Some(ty);
    }
}
pub struct OsdiNode {
    pub name: String,
    pub units: String,
    pub residual_units: String,
    pub resist_residual_off: u32,
    pub react_residual_off: u32,
    pub resist_limit_rhs_off: u32,
    pub react_limit_rhs_off: u32,
    pub is_flow: bool,
}
impl OsdiNode {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_str_uninterned(&self.units),
            ctx.const_str_uninterned(&self.residual_units),
            ctx.const_unsigned_int(self.resist_residual_off),
            ctx.const_unsigned_int(self.react_residual_off),
            ctx.const_unsigned_int(self.resist_limit_rhs_off),
            ctx.const_unsigned_int(self.react_limit_rhs_off),
            ctx.const_c_bool(self.is_flow),
        ];
        let ty = tys.osdi_node;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_node(&mut self) {
        let ctx = self.ctx;
        let fields = [
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_c_bool(),
        ];
        let ty = ctx.ty_struct("OsdiNode", &fields);
        self.osdi_node = Some(ty);
    }
}
pub struct OsdiParamOpvar {
    pub name: Vec<String>,
    pub num_alias: u32,
    pub description: String,
    pub units: String,
    pub flags: u32,
    pub len: u32,
}
impl OsdiParamOpvar {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let arr_0: Vec<_> = self.name.iter().map(|it| ctx.const_str_uninterned(it)).collect();
        let fields = [
            ctx.const_arr_ptr(ctx.ty_ptr(), &arr_0),
            ctx.const_unsigned_int(self.num_alias),
            ctx.const_str_uninterned(&self.description),
            ctx.const_str_uninterned(&self.units),
            ctx.const_unsigned_int(self.flags),
            ctx.const_unsigned_int(self.len),
        ];
        let ty = tys.osdi_param_opvar;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_param_opvar(&mut self) {
        let ctx = self.ctx;
        let fields =
            [ctx.ty_ptr(), ctx.ty_int(), ctx.ty_ptr(), ctx.ty_ptr(), ctx.ty_int(), ctx.ty_int()];
        let ty = ctx.ty_struct("OsdiParamOpvar", &fields);
        self.osdi_param_opvar = Some(ty);
    }
}
pub struct OsdiNoiseSource {
    pub name: String,
    pub nodes: OsdiNodePair,
}
impl OsdiNoiseSource {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [ctx.const_str_uninterned(&self.name), self.nodes.to_ll_val(ctx, tys)];
        let ty = tys.osdi_noise_source;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_noise_source(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_ptr(), self.osdi_node_pair.unwrap()];
        let ty = ctx.ty_struct("OsdiNoiseSource", &fields);
        self.osdi_noise_source = Some(ty);
    }
}
pub struct OsdiNatureRef {
    pub ref_type: u32,
    pub index: u32,
}
impl OsdiNatureRef {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [ctx.const_unsigned_int(self.ref_type), ctx.const_unsigned_int(self.index)];
        let ty = tys.osdi_nature_ref;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_nature_ref(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_int(), ctx.ty_int()];
        let ty = ctx.ty_struct("OsdiNatureRef", &fields);
        self.osdi_nature_ref = Some(ty);
    }
}
pub struct OsdiDescriptor<'ll> {
    pub name: String,
    pub num_nodes: u32,
    pub num_terminals: u32,
    pub nodes: Vec<OsdiNode>,
    pub num_jacobian_entries: u32,
    pub jacobian_entries: Vec<OsdiJacobianEntry>,
    pub num_collapsible: u32,
    pub collapsible: Vec<OsdiNodePair>,
    pub collapsed_offset: u32,
    pub noise_sources: Vec<OsdiNoiseSource>,
    pub num_noise_src: u32,
    pub num_params: u32,
    pub num_instance_params: u32,
    pub num_opvars: u32,
    pub param_opvar: Vec<OsdiParamOpvar>,
    pub node_mapping_offset: u32,
    pub jacobian_ptr_resist_offset: u32,
    pub num_states: u32,
    pub state_idx_off: u32,
    pub bound_step_offset: u32,
    pub instance_size: u32,
    pub model_size: u32,
    pub access: &'ll llvm_sys::LLVMValue,
    pub setup_model: &'ll llvm_sys::LLVMValue,
    pub setup_instance: &'ll llvm_sys::LLVMValue,
    pub eval: &'ll llvm_sys::LLVMValue,
    pub load_noise: &'ll llvm_sys::LLVMValue,
    pub load_residual_resist: &'ll llvm_sys::LLVMValue,
    pub load_residual_react: &'ll llvm_sys::LLVMValue,
    pub load_limit_rhs_resist: &'ll llvm_sys::LLVMValue,
    pub load_limit_rhs_react: &'ll llvm_sys::LLVMValue,
    pub load_spice_rhs_dc: &'ll llvm_sys::LLVMValue,
    pub load_spice_rhs_tran: &'ll llvm_sys::LLVMValue,
    pub load_jacobian_resist: &'ll llvm_sys::LLVMValue,
    pub load_jacobian_react: &'ll llvm_sys::LLVMValue,
    pub load_jacobian_tran: &'ll llvm_sys::LLVMValue,
    pub given_flag_model: &'ll llvm_sys::LLVMValue,
    pub given_flag_instance: &'ll llvm_sys::LLVMValue,
    pub num_resistive_jacobian_entries: u32,
    pub num_reactive_jacobian_entries: u32,
    pub write_jacobian_array_resist: &'ll llvm_sys::LLVMValue,
    pub write_jacobian_array_react: &'ll llvm_sys::LLVMValue,
    pub num_inputs: u32,
    pub inputs: Vec<OsdiNodePair>,
    pub load_jacobian_with_offset_resist: &'ll llvm_sys::LLVMValue,
    pub load_jacobian_with_offset_react: &'ll llvm_sys::LLVMValue,
    pub unknown_nature: Vec<OsdiNatureRef>,
    pub residual_nature: Vec<OsdiNatureRef>,
}
impl<'ll> OsdiDescriptor<'ll> {
    pub fn to_ll_val(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let arr_3: Vec<_> = self.nodes.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_5: Vec<_> = self.jacobian_entries.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_7: Vec<_> = self.collapsible.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_9: Vec<_> = self.noise_sources.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_14: Vec<_> = self.param_opvar.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_43: Vec<_> = self.inputs.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_46: Vec<_> = self.unknown_nature.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let arr_47: Vec<_> = self.residual_nature.iter().map(|it| it.to_ll_val(ctx, tys)).collect();
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_unsigned_int(self.num_nodes),
            ctx.const_unsigned_int(self.num_terminals),
            ctx.const_arr_ptr(tys.osdi_node, &arr_3),
            ctx.const_unsigned_int(self.num_jacobian_entries),
            ctx.const_arr_ptr(tys.osdi_jacobian_entry, &arr_5),
            ctx.const_unsigned_int(self.num_collapsible),
            ctx.const_arr_ptr(tys.osdi_node_pair, &arr_7),
            ctx.const_unsigned_int(self.collapsed_offset),
            ctx.const_arr_ptr(tys.osdi_noise_source, &arr_9),
            ctx.const_unsigned_int(self.num_noise_src),
            ctx.const_unsigned_int(self.num_params),
            ctx.const_unsigned_int(self.num_instance_params),
            ctx.const_unsigned_int(self.num_opvars),
            ctx.const_arr_ptr(tys.osdi_param_opvar, &arr_14),
            ctx.const_unsigned_int(self.node_mapping_offset),
            ctx.const_unsigned_int(self.jacobian_ptr_resist_offset),
            ctx.const_unsigned_int(self.num_states),
            ctx.const_unsigned_int(self.state_idx_off),
            ctx.const_unsigned_int(self.bound_step_offset),
            ctx.const_unsigned_int(self.instance_size),
            ctx.const_unsigned_int(self.model_size),
            self.access,
            self.setup_model,
            self.setup_instance,
            self.eval,
            self.load_noise,
            self.load_residual_resist,
            self.load_residual_react,
            self.load_limit_rhs_resist,
            self.load_limit_rhs_react,
            self.load_spice_rhs_dc,
            self.load_spice_rhs_tran,
            self.load_jacobian_resist,
            self.load_jacobian_react,
            self.load_jacobian_tran,
            self.given_flag_model,
            self.given_flag_instance,
            ctx.const_unsigned_int(self.num_resistive_jacobian_entries),
            ctx.const_unsigned_int(self.num_reactive_jacobian_entries),
            self.write_jacobian_array_resist,
            self.write_jacobian_array_react,
            ctx.const_unsigned_int(self.num_inputs),
            ctx.const_arr_ptr(tys.osdi_node_pair, &arr_43),
            self.load_jacobian_with_offset_resist,
            self.load_jacobian_with_offset_react,
            ctx.const_arr_ptr(tys.osdi_nature_ref, &arr_46),
            ctx.const_arr_ptr(tys.osdi_nature_ref, &arr_47),
        ];
        let ty = tys.osdi_descriptor;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_descriptor(&mut self) {
        let ctx = self.ctx;
        let fields = [
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
            ctx.ty_ptr(),
        ];
        let ty = ctx.ty_struct("OsdiDescriptor", &fields);
        self.osdi_descriptor = Some(ty);
    }
}
pub struct OsdiNature {
    pub name: String,
    pub parent_type: u32,
    pub parent: u32,
    pub ddt: u32,
    pub idt: u32,
    pub attr_start: u32,
    pub num_attr: u32,
}
impl OsdiNature {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_unsigned_int(self.parent_type),
            ctx.const_unsigned_int(self.parent),
            ctx.const_unsigned_int(self.ddt),
            ctx.const_unsigned_int(self.idt),
            ctx.const_unsigned_int(self.attr_start),
            ctx.const_unsigned_int(self.num_attr),
        ];
        let ty = tys.osdi_nature;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_nature(&mut self) {
        let ctx = self.ctx;
        let fields = [
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
        ];
        let ty = ctx.ty_struct("OsdiNature", &fields);
        self.osdi_nature = Some(ty);
    }
}
pub struct OsdiDiscipline {
    pub name: String,
    pub flow: u32,
    pub potential: u32,
    pub domain: u32,
    pub attr_start: u32,
    pub num_flow_attr: u32,
    pub num_potential_attr: u32,
    pub num_user_attr: u32,
}
impl OsdiDiscipline {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_unsigned_int(self.flow),
            ctx.const_unsigned_int(self.potential),
            ctx.const_unsigned_int(self.domain),
            ctx.const_unsigned_int(self.attr_start),
            ctx.const_unsigned_int(self.num_flow_attr),
            ctx.const_unsigned_int(self.num_potential_attr),
            ctx.const_unsigned_int(self.num_user_attr),
        ];
        let ty = tys.osdi_discipline;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_discipline(&mut self) {
        let ctx = self.ctx;
        let fields = [
            ctx.ty_ptr(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
            ctx.ty_int(),
        ];
        let ty = ctx.ty_struct("OsdiDiscipline", &fields);
        self.osdi_discipline = Some(ty);
    }
}
pub enum OsdiAttributeValue {
    String(String),
    Integer(i32),
    Real(f64),
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_attribute_value(&mut self) {
        let ctx = self.ctx;
        unsafe {
            let align = [
                llvm_sys::target::LLVMABIAlignmentOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_ptr()).as_ptr(),
                ),
                llvm_sys::target::LLVMABIAlignmentOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_int()).as_ptr(),
                ),
                llvm_sys::target::LLVMABIAlignmentOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_double()).as_ptr(),
                ),
            ]
            .into_iter()
            .max()
            .unwrap();
            let mut size = [
                llvm_sys::target::LLVMABISizeOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_ptr()).as_ptr(),
                ),
                llvm_sys::target::LLVMABISizeOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_int()).as_ptr(),
                ),
                llvm_sys::target::LLVMABISizeOfType(
                    self.target_data.clone(),
                    core::ptr::NonNull::from(ctx.ty_double()).as_ptr(),
                ),
            ]
            .into_iter()
            .max()
            .unwrap() as u32;
            size = (size + align - 1) / align;
            let elem = ctx.ty_aint(align * 8);
            let ty = ctx.ty_array(elem, size);
            self.osdi_attribute_value = Some(ty);
        }
    }
}
pub struct OsdiAttribute {
    pub name: String,
    pub value_type: u32,
    pub value: OsdiAttributeValue,
}
impl OsdiAttribute {
    pub fn to_ll_val<'ll>(
        &self,
        ctx: &CodegenCx<'_, 'll>,
        tys: &'ll OsdiTys,
    ) -> &'ll llvm_sys::LLVMValue {
        let fields = [
            ctx.const_str_uninterned(&self.name),
            ctx.const_unsigned_int(self.value_type),
            self.value.to_ll_val(ctx, tys),
        ];
        let ty = tys.osdi_attribute;
        ctx.const_struct(ty, &fields)
    }
}
impl OsdiTyBuilder<'_, '_, '_> {
    fn osdi_attribute(&mut self) {
        let ctx = self.ctx;
        let fields = [ctx.ty_ptr(), ctx.ty_int(), self.osdi_attribute_value.unwrap()];
        let ty = ctx.ty_struct("OsdiAttribute", &fields);
        self.osdi_attribute = Some(ty);
    }
}
#[derive(Clone)]
pub struct OsdiTys<'ll> {
    pub osdi_lim_function: &'ll llvm_sys::LLVMType,
    pub osdi_sim_paras: &'ll llvm_sys::LLVMType,
    pub osdi_sim_info: &'ll llvm_sys::LLVMType,
    pub osdi_init_error_payload: &'ll llvm_sys::LLVMType,
    pub osdi_init_error: &'ll llvm_sys::LLVMType,
    pub osdi_init_info: &'ll llvm_sys::LLVMType,
    pub osdi_node_pair: &'ll llvm_sys::LLVMType,
    pub osdi_jacobian_entry: &'ll llvm_sys::LLVMType,
    pub osdi_node: &'ll llvm_sys::LLVMType,
    pub osdi_param_opvar: &'ll llvm_sys::LLVMType,
    pub osdi_noise_source: &'ll llvm_sys::LLVMType,
    pub osdi_nature_ref: &'ll llvm_sys::LLVMType,
    pub osdi_descriptor: &'ll llvm_sys::LLVMType,
    pub osdi_nature: &'ll llvm_sys::LLVMType,
    pub osdi_discipline: &'ll llvm_sys::LLVMType,
    pub osdi_attribute_value: &'ll llvm_sys::LLVMType,
    pub osdi_attribute: &'ll llvm_sys::LLVMType,
}
impl<'ll> OsdiTys<'ll> {
    pub fn new(ctx: &CodegenCx<'_, 'll>, target_data: &inkwell::targets::TargetData) -> Self {
        // Convert inkwell TargetData to raw pointer for internal use
        // TODO: Migrate internal implementation to use inkwell TargetData directly
        use inkwell::llvm_sys::target_machine::LLVMCreateTargetDataLayout;
        use inkwell::llvm_sys::target::LLVMGetDataLayoutStr;
        use std::ffi::CStr;
        let raw_target_data = unsafe {
            let layout_str = target_data.get_data_layout();
            let layout_cstr = std::ffi::CString::new(layout_str.to_str().unwrap()).unwrap();
            inkwell::llvm_sys::target::LLVMCreateTargetData(layout_cstr.as_ptr())
        };
        Self::new_from_raw(ctx, raw_target_data)
    }

    fn new_from_raw(ctx: &CodegenCx<'_, 'll>, target_data: llvm_sys::target::LLVMTargetDataRef) -> Self {
        let mut builder = OsdiTyBuilder {
            ctx,
            target_data,
            osdi_lim_function: None,
            osdi_sim_paras: None,
            osdi_sim_info: None,
            osdi_init_error_payload: None,
            osdi_init_error: None,
            osdi_init_info: None,
            osdi_node_pair: None,
            osdi_jacobian_entry: None,
            osdi_node: None,
            osdi_param_opvar: None,
            osdi_noise_source: None,
            osdi_nature_ref: None,
            osdi_descriptor: None,
            osdi_nature: None,
            osdi_discipline: None,
            osdi_attribute_value: None,
            osdi_attribute: None,
        };
        builder.osdi_lim_function();
        builder.osdi_sim_paras();
        builder.osdi_sim_info();
        builder.osdi_init_error_payload();
        builder.osdi_init_error();
        builder.osdi_init_info();
        builder.osdi_node_pair();
        builder.osdi_jacobian_entry();
        builder.osdi_node();
        builder.osdi_param_opvar();
        builder.osdi_noise_source();
        builder.osdi_nature_ref();
        builder.osdi_descriptor();
        builder.osdi_nature();
        builder.osdi_discipline();
        builder.osdi_attribute_value();
        builder.osdi_attribute();
        builder.finish()
    }
}
struct OsdiTyBuilder<'a, 'b, 'll> {
    ctx: &'a CodegenCx<'b, 'll>,
    target_data: llvm_sys::target::LLVMTargetDataRef,
    osdi_lim_function: Option<&'ll llvm_sys::LLVMType>,
    osdi_sim_paras: Option<&'ll llvm_sys::LLVMType>,
    osdi_sim_info: Option<&'ll llvm_sys::LLVMType>,
    osdi_init_error_payload: Option<&'ll llvm_sys::LLVMType>,
    osdi_init_error: Option<&'ll llvm_sys::LLVMType>,
    osdi_init_info: Option<&'ll llvm_sys::LLVMType>,
    osdi_node_pair: Option<&'ll llvm_sys::LLVMType>,
    osdi_jacobian_entry: Option<&'ll llvm_sys::LLVMType>,
    osdi_node: Option<&'ll llvm_sys::LLVMType>,
    osdi_param_opvar: Option<&'ll llvm_sys::LLVMType>,
    osdi_noise_source: Option<&'ll llvm_sys::LLVMType>,
    osdi_nature_ref: Option<&'ll llvm_sys::LLVMType>,
    osdi_descriptor: Option<&'ll llvm_sys::LLVMType>,
    osdi_nature: Option<&'ll llvm_sys::LLVMType>,
    osdi_discipline: Option<&'ll llvm_sys::LLVMType>,
    osdi_attribute_value: Option<&'ll llvm_sys::LLVMType>,
    osdi_attribute: Option<&'ll llvm_sys::LLVMType>,
}
impl<'ll> OsdiTyBuilder<'_, '_, 'll> {
    fn finish(self) -> OsdiTys<'ll> {
        OsdiTys {
            osdi_lim_function: self.osdi_lim_function.unwrap(),
            osdi_sim_paras: self.osdi_sim_paras.unwrap(),
            osdi_sim_info: self.osdi_sim_info.unwrap(),
            osdi_init_error_payload: self.osdi_init_error_payload.unwrap(),
            osdi_init_error: self.osdi_init_error.unwrap(),
            osdi_init_info: self.osdi_init_info.unwrap(),
            osdi_node_pair: self.osdi_node_pair.unwrap(),
            osdi_jacobian_entry: self.osdi_jacobian_entry.unwrap(),
            osdi_node: self.osdi_node.unwrap(),
            osdi_param_opvar: self.osdi_param_opvar.unwrap(),
            osdi_noise_source: self.osdi_noise_source.unwrap(),
            osdi_nature_ref: self.osdi_nature_ref.unwrap(),
            osdi_descriptor: self.osdi_descriptor.unwrap(),
            osdi_nature: self.osdi_nature.unwrap(),
            osdi_discipline: self.osdi_discipline.unwrap(),
            osdi_attribute_value: self.osdi_attribute_value.unwrap(),
            osdi_attribute: self.osdi_attribute.unwrap(),
        }
    }
}

# OSDI Architecture and Parameter Handling

This document describes the Open Simulator Device Interface (OSDI) architecture, how simulators (VACASK, ngspice) interface with OSDI compiled models, and how this relates to JAX-SPICE's parameter handling through `openvaf_jax`.

## 1. Overview

OSDI is the interface between OpenVAF-compiled Verilog-A device models and circuit simulators. There are several integration paths:

- **VACASK / ngspice**: Load OSDI shared libraries (.so/.dylib) at runtime and use native compiled code directly
- **openvaf_jax**: Translates OpenVAF's MIR to JAX Python functions for GPU-accelerated simulation

## 2. OSDI Parameter Kinds

OSDI defines three parameter kinds in the descriptor:

```c
// From OSDI header
#define PARA_KIND_MODEL 0   // Model-level parameters (shared across instances)
#define PARA_KIND_INST  1   // Instance-level parameters (per-device)
#define PARA_KIND_OPVAR 2   // Output variables (computed, read-only)
```

### Model Parameters (`PARA_KIND_MODEL`)

- Shared across all instances of a model (e.g., all psp103n devices)
- Typically process parameters, physical constants
- Examples: `toxe`, `vth0`, `k1`, `k2`
- Stored in model data structure at `descriptor->model_size` bytes

### Instance Parameters (`PARA_KIND_INST`)

- Per-device parameters
- Geometry, placement, multipliers
- Examples: `w`, `l`, `nf`, `mult`, `sa`, `sb`
- Stored in instance data structure at `descriptor->instance_size` bytes

### Output Variables (`PARA_KIND_OPVAR`)

- Computed during evaluation
- Read-only to the simulator
- Examples: `ids`, `gm`, `gds`, `vth`
- Extracted after eval for probing/measurement

## 3. OSDI Library Interface

### Library Loading

**Files:** `VACASK/lib/dynload.cpp`, `VACASK/lib/osdifile.cpp`

```cpp
OsdiFile::open()
  └─> openDynamicLibrary(filename)
      ├─> dlopen(filename, RTLD_NOW) [Linux/macOS]
      └─> LoadLibrary(filename) [Windows]
```

**Symbols Retrieved from Library:**
- `OSDI_DESCRIPTORS` - Array of device descriptors
- `OSDI_NUM_DESCRIPTORS` - Number of devices
- `OSDI_VERSION_MAJOR/MINOR` - API version
- `OSDI_LIM_TABLE` - Limit function table
- `osdi_log` - Logging callback

### Parameter Access

Parameters are accessed through a callback function pointer in the descriptor:

```c
void *(*access)(void *inst, void *model, uint32_t id, uint32_t flags)
```

**Access Flags:**
- `ACCESS_FLAG_READ` (0) - Read parameter
- `ACCESS_FLAG_SET` (1) - Set parameter
- `ACCESS_FLAG_INSTANCE` (4) - Instance vs model parameter

**Parameter Storage:**
- Model data: allocated at `descriptor->model_size` bytes
- Instance data: allocated at `descriptor->instance_size` bytes
- Parameters stored at offsets within these structures

## 4. Voltage and State Handling

### Voltage Provision to Models

Voltages are NOT passed as function arguments. Instead:

1. **Node Mapping Setup:**
   ```cpp
   auto nodeMapping = nodeMappingArray();  // at descriptor->node_mapping_offset
   nodeMapping[i] = nodes_[i]->unknownIndex();  // circuit matrix index
   ```

2. **Solution Vector Passed via OsdiSimInfo:**
   ```cpp
   simInfo.prev_solve = evalSetup->oldSolution;  // entire circuit solution
   ```

3. **Model Reads Voltages Internally:**
   ```c
   // Inside OSDI model (generated by OpenVAF)
   voltage_at_node_i = prev_solve[nodeMapping[i]];
   ```

### OSDI Internal States

**Critical distinction:** OSDI has a concept of "internal states" that is separate from parameters. These are used for:

- `$limit()` function state (voltage limiting for convergence)
- `ddt()` integration state
- Other time-dependent constructs

```c
typedef struct OsdiSimInfo {
    // ...
    double *prev_state;   // Previous internal state array
    double *next_state;   // Next internal state array
    // ...
} OsdiSimInfo;
```

During evaluation:
1. Model reads from `prev_state` (previous timestep/iteration)
2. Model writes to `next_state` (current computation)
3. After convergence, simulator swaps: `prev_state = next_state`

These are for convergence aids and time integration, NOT for geometry calculations.

## 5. The Eval Function

**Signature:**
```c
uint32_t (*eval)(void *handle, void *inst, void *model, OsdiSimInfo *info)
```

**Called From:** `OsdiInstance::evalCore()` in osdiinstance.cpp

```cpp
auto evalFlags = descr->eval(&handle, core(), model_->core(), &simInfo);
```

**OsdiSimInfo Structure:**
```c
typedef struct OsdiSimInfo {
    OsdiSimParas paras;      // gmin, tnom, scale, iteration, etc.
    double abstime;          // Current simulation time
    double *prev_solve;      // Circuit solution vector (node voltages!)
    double *prev_state;      // Previous internal state
    double *next_state;      // Next internal state
    uint32_t flags;          // What to compute
} OsdiSimInfo;
```

**Calculation Flags:**
- `CALC_RESIST_RESIDUAL` - Compute resistive residual (f)
- `CALC_REACT_RESIDUAL` - Compute reactive residual (q)
- `CALC_RESIST_JACOBIAN` - Compute resistive Jacobian (df/dx)
- `CALC_REACT_JACOBIAN` - Compute reactive Jacobian (dq/dx)
- `ANALYSIS_DC` / `ANALYSIS_TRAN` / `ANALYSIS_AC`
- `ENABLE_LIM` / `INIT_LIM` - Limiting control

### Jacobian Handling

Jacobians are NOT returned by eval(). Instead, matrix pointers are bound beforehand, and the model writes directly to them.

**Binding Phase (before iteration):**
```cpp
// From bindCore()
auto jacResistArray = resistiveJacobianPointers();  // at descriptor->jacobian_ptr_resist_offset
for(auto& entry : jacobian_entries) {
    jacResistArray[i] = matResist->valuePtr(row, col);  // Direct matrix pointer!
}
```

**During Eval:** The OSDI model writes Jacobian values directly to the bound matrix pointers.

**Load Phase (after eval):**
```cpp
descr->load_jacobian_resist(core(), model_->core());
descr->load_jacobian_react(core(), model_->core(), factor);
```

### Residual Handling

Residuals are stored in the instance core structure at offsets:
```c
// OsdiNode structure
uint32_t resist_residual_off;   // Offset to resistive residual
uint32_t react_residual_off;    // Offset to reactive residual
```

**Extraction:**
```cpp
for(auto i : device->nonzeroResistiveResiduals()) {
    auto resOff = descr->nodes[i].resist_residual_off;
    auto contrib = *getDataPtr<double*>(core(), resOff);
    // Load to matrix RHS
}
```

## 6. Complete Evaluation Flow

```
1. SETUP PHASE:
   Circuit::setup()
     └─> OsdiDevice::setup()
         └─> OsdiInstance::setup()
             └─> setup_instance(handle, core, model_core, temp)
                 └─> Allocate internal states

2. BIND PHASE (once per matrix structure change):
   OsdiInstance::bindCore()
     └─> Bind Jacobian pointers to matrix entries
     └─> Bind node mapping to circuit unknowns

3. ITERATION LOOP (Newton-Raphson):
   OsdiDevice::evalAndLoad()

   a. Populate OsdiSimInfo:
      ├─> simInfo.paras = {gmin, tnom, scale, iteration, ...}
      ├─> simInfo.abstime = current_time
      ├─> simInfo.prev_solve = circuit_solution_vector  // VOLTAGES HERE!
      ├─> simInfo.prev_state = previous_internal_states
      ├─> simInfo.next_state = next_internal_states
      └─> simInfo.flags = CALC_RESIST_RESIDUAL | CALC_RESIST_JACOBIAN | ...

   b. For each instance:
      eval(&handle, instance_core, model_core, &simInfo)
        └─> Model internally:
            ├─> Reads voltages: V[i] = prev_solve[nodeMapping[i]]
            ├─> Computes currents, charges
            ├─> Writes residuals to instance_core offsets
            ├─> Writes Jacobians DIRECTLY to matrix pointers
            └─> Updates internal states

   c. For each instance:
      loadCore()
        ├─> load_residual_resist() → to matrix RHS
        ├─> load_residual_react() → to matrix RHS
        └─> Jacobians already written by eval!

4. SOLVE and repeat until converged
```

## 7. The Init/Eval Split and Hidden State

### OpenVAF's Architecture

OpenVAF optimizes Verilog-A code by splitting computation into two phases:

1. **Init phase**: Runs once per parameter change, computes values that don't depend on voltages
2. **Eval phase**: Runs every NR iteration, uses cached values + voltages to compute currents/Jacobians

### openvaf_py's "hidden_state"

In `openvaf_py` (Rust bindings for OpenVAF's MIR interpreter), `hidden_state` refers to values computed by the init function and cached for use in the eval function:

```rust
// From openvaf_py/src/lib.rs
pub enum ParamKind {
    Param,        // Regular parameters
    DepBreak,     // Dependency break points
    ParamHidden,  // Hidden model params (not in OSDI)
    Voltage,      // Node voltages
    Current,      // Branch currents
    HiddenState,  // <-- Values computed by init, cached for eval
    StateLim,     // Limit function state
    Temperature,  // Temperature
}
```

**Note:** This is entirely different from OSDI's internal states (which are for `$limit()` and `ddt()`).

### Examples of hidden_state Values

For PSP103, the init function computes ~462 cached values:

| Value | Computation | Purpose |
|-------|-------------|---------|
| `invNF` | `1.0 / NF` | Inverse number of fingers |
| `LE`, `WE` | Effective length/width after binning | Geometry |
| `iL`, `iW` | `1.0 / L`, `1.0 / W` | Inverse geometry |
| `iLE`, `iWE` | `1.0 / LE`, `1.0 / WE` | Inverse effective geometry |
| `inv_phit` | `1.0 / (kT/q)` | Inverse thermal voltage |
| `chnl_type` | 1 or -1 | NMOS vs PMOS |

### The Hidden State Flow

```
Verilog-A variable 'real LE;'
    ↓
ParamKind::HiddenState(LE) created in MIR
    ↓
insert_var_init() replaces HiddenState with actual computation
    ↓
Initialization::new() moves computation to init function
    ↓
Value becomes a cache slot in cached_vals
    ↓
cache_mapping connects init output → eval input param
```

## 8. Translation Pipeline

### OpenVAF Compilation (VACASK/ngspice path)

```
Verilog-A source
    ↓
OpenVAF Compiler
    ↓
OSDI shared library (.so/.dylib)
```

The OSDI library contains native code with the init/eval split built-in.

### openvaf_jax Translation (JAX-SPICE path)

```
Verilog-A source
    ↓
OpenVAF Compiler (partial - to MIR)
    ↓
openvaf_py (Rust MIR interpreter)
    ↓
openvaf_jax.py (MIR → JAX translator)
    ↓
JAX Python functions
```

The JAX translator must replicate the init/eval split:

1. **Init phase**: Computes cached values from parameters
2. **Cache mapping**: Passes cached values to eval via variable assignments
3. **Eval phase**: Uses cached values + voltages to compute currents/Jacobians

## 9. Comparison: Native Simulators vs JAX-SPICE

| Aspect | VACASK / ngspice + OSDI | openvaf_jax |
|--------|-------------------------|-------------|
| Code type | Native compiled (.so) | JAX Python functions |
| Voltage input | Via prev_solve array + node mapping | Direct function arguments |
| Jacobian output | Direct write to matrix pointers | Returned as dictionary |
| Residual output | Read from instance core offsets | Returned as dictionary |
| Autodiff | Not used - analytical Jacobians | Can use JAX autodiff |
| Init execution | Native code, once per setup | Should use generated JAX init |
| Cache passing | Automatic in native code | Manual via cache_mapping |
| Vectorization | Per-device sequential | Batched vmap over devices |
| GPU support | CPU only | Full JAX GPU acceleration |

## 10. Architectural Analysis

### Current Issues with openvaf_jax

1. **Eval function's hidden_state params are UNUSED**
   - `insert_var_init` replaces all HiddenState references with computed values
   - After this pass, HiddenState params have 0 operand references in eval

2. **Misleading API**: Exposing hidden_state in eval params suggests they're inputs, but they're unused

3. **Manual computation in runner.py**: Because workarounds fail for batched execution, runner.py manually computes ~40 hidden_state values, missing 1600+

### Recommended Architecture

**Current (Problematic):**
```
runner.py manually sets ~40 hidden_state params
    ↓
Generated eval function expects all 1705 values
    ↓
Missing values = 0 → Division by zero → NaN
```

**Proposed Solution:**
```
runner.py sets only regular params (l, w, nf, etc.)
    ↓
Generated init function computes all hidden_state
    ↓
Cache passed to eval function
    ↓
No manual geometry computation needed
```

This requires:
1. `openvaf_jax.py` to generate a proper init function
2. `runner.py` to call init before eval
3. Batched init execution via vmap

### Implications for GPU Solver

The GPU solver currently uses JAX autodiff for Jacobians, but this misses:

1. **Minimum Conductances:** OSDI models enforce `gds >= GDSMIN`, autodiff doesn't
2. **Limiting Functions:** `$limit()` in Verilog-A handled by OSDI, not autodiff
3. **Analytical Derivatives:** OpenVAF computes symbolic derivatives with numerical stability

**Solution:** Use `openvaf_jax` to get the same analytical Jacobians that OSDI models provide, rather than relying on autodiff.

## 11. File References

| Purpose | File |
|---------|------|
| OSDI header definitions | `openvaf-py/vendor/OpenVAF/openvaf/osdi/header/osdi.h` |
| Rust MIR interpreter | `openvaf-py/src/lib.rs` |
| JAX code translator | `openvaf-py/openvaf_jax.py` |
| Benchmark runner | `jax_spice/benchmarks/runner.py` |
| Library loading | `VACASK/lib/dynload.cpp`, `VACASK/lib/osdifile.cpp` |
| Instance evaluation | `VACASK/lib/osdiinstance.cpp` |
| Device management | `VACASK/lib/osdidevice.cpp` |
| OSDI API definitions | `VACASK/include/osdi.h` |
| Parameter access | `VACASK/lib/osdimodel.cpp` |
